# two-sum

## Descripción
¿Puede solucionarlo?
Qué dos números positivos pueden hacer esto posible: `n1 > n1 + n2 OR n2 > n1 + n2`
Introdúcelos aquí `nc saturn.picoctf.net 52317`. [Fuente](https://artifacts.picoctf.net/c/453/flag.c)

## Pistas
- Desbordamiento de enteros
- No es necesariamente un problema matemático

## Solución
```bash
┌──(kali㉿kali)-[~/picoctf/b_exploitation/two-sum]
└─$ cat flag.c
#include <stdio.h>
#include <stdlib.h>

static int addIntOvf(int result, int a, int b) {
    result = a + b;
    if(a > 0 && b > 0 && result < 0)
        return -1;
    if(a < 0 && b < 0 && result > 0)
        return -1;
    return 0;
}

int main() {
    int num1, num2, sum;
    FILE *flag;
    char c;

    printf("n1 > n1 + n2 OR n2 > n1 + n2 \n");
    fflush(stdout);
    printf("What two positive numbers can make this possible: \n");
    fflush(stdout);
    
    if (scanf("%d", &num1) && scanf("%d", &num2)) {
        printf("You entered %d and %d\n", num1, num2);
        fflush(stdout);
        sum = num1 + num2;
        if (addIntOvf(sum, num1, num2) == 0) {
            printf("No overflow\n");
            fflush(stdout);
            exit(0);
        } else if (addIntOvf(sum, num1, num2) == -1) {
            printf("You have an integer overflow\n");
            fflush(stdout);
        }

        if (num1 > 0 || num2 > 0) {
            flag = fopen("flag.txt","r");
            if(flag == NULL){
                printf("flag not found: please run this on the server\n");
                fflush(stdout);
                exit(0);
            }
            char buf[60];
            fgets(buf, 59, flag);
            printf("YOUR FLAG IS: %s\n", buf);
            fflush(stdout);
            exit(0);
        }
    }
    return 0;
}
                                                                                                                                              
┌──(kali㉿kali)-[~/picoctf/b_exploitation/two-sum]
└─$ nc saturn.picoctf.net 52317
n1 > n1 + n2 OR n2 > n1 + n2 
What two positive numbers can make this possible: 
2147483647
5
You entered 2147483647 and 5
You have an integer overflow
YOUR FLAG IS: picoCTF{Tw0_Sum_Integer_Bu773R_0v3rfl0w_482d8fc4}
```

## Bandera
picoCTF{Tw0_Sum_Integer_Bu773R_0v3rfl0w_482d8fc4}

## Notas adicionales
>[!danger]
>**Integer Overflow**
>Como cualquier otra variable, los enteros son sólo algunos bytes de memoria. Todos los ordenadores modernos admiten enteros de 32 y 64 bits. También existen tipos de datos más pequeños, como short int, que ocupan 16 bits. Dado que se asigna una cantidad fija de bits para almacenar enteros, naturalmente, existe un límite finito para representar un entero correctamente. Estos límites se definen en la cabecera limits.h.
>El número más grande que puede guardar un entero en c es 2147483647 o $2^{31} - 1$.

## Referencias
[Overflow and Underflow in C](https://www.scaler.com/topics/c/overflow-and-underflow-in-c/)